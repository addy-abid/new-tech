"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.command = void 0;
const tslib_1 = require("tslib");
const lint_1 = require("./lint");
const output_1 = require("./output");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = require("fs");
async function command(options, 
/**
 * @deprecated
 */
exitCode) {
    var _a, _b, _c, _d, _e, _f;
    const fix = (_a = options.fix) !== null && _a !== void 0 ? _a : false;
    const workspace = (_b = options.workspace) !== null && _b !== void 0 ? _b : process.cwd();
    const configFile = options.configFile ? path_1.default.join(process.cwd(), options.configFile) : options.configFile;
    const format = (_c = options.format) !== null && _c !== void 0 ? _c : 'standard';
    const color = (_d = options.color) !== null && _d !== void 0 ? _d : true;
    const problemOnly = (_e = options.problemOnly) !== null && _e !== void 0 ? _e : false;
    const verbose = (_f = options.verbose) !== null && _f !== void 0 ? _f : false;
    const reports = await lint_1.lint({
        files: options.files,
        sourceCodes: options.codes,
        workspace,
        config: configFile,
        fix,
        rulesAutoResolve: true,
    });
    if (fix) {
        for (const report of reports) {
            await fs_1.promises.writeFile(report.filePath, report.fixedCode, { encoding: 'utf8' });
            process.stdout.write(`markuplint: Fix "${report.filePath}"\n`);
        }
    }
    else {
        for (const result of reports) {
            await output_1.output(Object.assign(Object.assign({}, result), { format,
                color,
                problemOnly, noStdOut: false, verbose }));
        }
    }
    process.exit(exitCode !== null && exitCode !== void 0 ? exitCode : process.exitCode);
}
exports.command = command;
