"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintFile = void 0;
const tslib_1 = require("tslib");
const ml_core_1 = require("@markuplint/ml-core");
const i18n_1 = require("./i18n");
const module_auto_loader_1 = require("./module-auto-loader");
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("./util");
async function lintFile(file, configs, rulesAutoResolve, rules, locale, fix, extMatch) {
    const configSet = configs.get(file) || {
        config: {},
        files: new Set(),
        errs: [],
    };
    // Exclude
    const excludeFiles = configSet.config.excludeFiles || [];
    for (const excludeFile of excludeFiles) {
        if (file.matches(excludeFile)) {
            return null;
        }
    }
    // Get parser
    let parserModName = '@markuplint/html-parser';
    let matched = false;
    if (configSet.config.parser) {
        for (const pattern of Object.keys(configSet.config.parser)) {
            if (path_1.default.basename(file.path).match(util_1.toRegxp(pattern))) {
                parserModName = configSet.config.parser[pattern];
                matched = true;
            }
        }
    }
    const parser = await Promise.resolve().then(() => tslib_1.__importStar(require(parserModName)));
    const parserOptions = configSet.config.parserOptions || {};
    // Ext Matching
    if (extMatch && !matched && !path_1.default.basename(file.path).match(/\.html?$/i)) {
        return null;
    }
    // Resolve ruleset
    const ruleset = ml_core_1.convertRuleset(configSet.config);
    // Schemas
    const specs = configSet.config.specs
        ? Array.isArray(configSet.config.specs)
            ? configSet.config.specs
            : [configSet.config.specs]
        : [];
    const htmlSpec = await Promise.resolve().then(() => tslib_1.__importStar(require('@markuplint/html-spec')));
    const extendedSpecs = await Promise.all(specs.map(async (spec) => (await Promise.resolve().then(() => tslib_1.__importStar(require(spec)))).default));
    const schemas = [htmlSpec, ...extendedSpecs];
    // Addition rules
    if (rulesAutoResolve) {
        const { rules: additionalRules } = await module_auto_loader_1.moduleAutoLoader(ruleset);
        rules = rules.concat(...additionalRules);
    }
    // create MLCore
    const sourceCode = await file.getContext();
    const i18nSettings = await i18n_1.i18n(locale);
    let results = [];
    let fixedCode = sourceCode;
    let document = null;
    try {
        const core = new ml_core_1.MLCore(parser, sourceCode, ruleset, rules, i18nSettings, schemas, parserOptions, file.path);
        results = await core.verify(fix);
        fixedCode = core.document.toString();
        document = core.document;
    }
    catch (err) {
        if (err instanceof ml_core_1.MLParseError) {
            results = [
                {
                    ruleId: 'parse-error',
                    severity: 'error',
                    message: err.message,
                    col: err.col,
                    line: err.line,
                    raw: err.raw,
                },
            ];
        }
        else {
            throw err;
        }
    }
    return {
        results,
        filePath: file.path,
        sourceCode,
        fixedCode,
        document,
        parser: parserModName,
        locale,
        ruleset,
        configSet: {
            config: configSet.config,
            files: Array.from(configSet.files),
            error: configSet.errs.map(e => `${e}`),
        },
    };
}
exports.lintFile = lintFile;
