"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAria = exports.checkAriaValue = exports.getComputedRole = exports.getImplicitRole = exports.getPermittedRoles = exports.getRoleSpec = exports.ariaSpec = exports.isValidAttr = exports.htmlSpec = exports.rePCENChar = exports.match = exports.attrMatches = exports.getAttrSpecs = void 0;
const tslib_1 = require("tslib");
const html_spec_1 = tslib_1.__importDefault(require("@markuplint/html-spec"));
const type_check_1 = require("./type-check");
function getAttrSpecs(tag, { specs, def }) {
    tag = tag.toLowerCase();
    const spec = specs.find(spec => spec.name === tag);
    if (!spec) {
        return null;
    }
    const hasGlobalAttr = spec.attributes.some(attr => attr === '#globalAttrs');
    const attrs = [];
    if (hasGlobalAttr) {
        attrs.push(...def['#globalAttrs']);
    }
    for (const attr of spec.attributes) {
        if (typeof attr === 'string') {
            continue;
        }
        const definedIndex = attrs.findIndex(a => a.name === attr.name);
        if (definedIndex !== -1) {
            attrs[definedIndex] = Object.assign(Object.assign({}, attrs[definedIndex]), attr);
            continue;
        }
        attrs.push(attr);
    }
    return attrs;
}
exports.getAttrSpecs = getAttrSpecs;
function attrMatches(node, condition) {
    if (!condition) {
        return true;
    }
    let matched = false;
    if (condition.self) {
        const condSelector = Array.isArray(condition.self) ? condition.self.join(',') : condition.self;
        matched = node.matches(condSelector);
    }
    if (condition.ancestor) {
        let _node = node.parentNode;
        while (_node) {
            if (_node.type === 'Element') {
                if (_node.matches(condition.ancestor)) {
                    matched = true;
                    break;
                }
            }
            _node = _node.parentNode;
        }
    }
    return matched;
}
exports.attrMatches = attrMatches;
function match(needle, pattern) {
    const matches = pattern.match(/^\/(.*)\/(i|g|m)*$/);
    if (matches && matches[1]) {
        const re = matches[1];
        const flag = matches[2];
        return new RegExp(re, flag).test(needle);
    }
    return needle === pattern;
}
exports.match = match;
/**
 * PotentialCustomElementName
 *
 * @see https://html.spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname
 *
 * > PotentialCustomElementName ::=
 * >   [a-z] (PCENChar)* '-' (PCENChar)*
 * > PCENChar ::=
 * >   "-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
 * >   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
 * > This uses the EBNF notation from the XML specification. [XML]
 *
 * ASCII-case-insensitively.
 * Originally, it is not possible to define a name including ASCII upper alphas in the custom element, but it is not treated as illegal by the HTML parser.
 */
exports.rePCENChar = [
    '\\-',
    '\\.',
    '[0-9]',
    '_',
    '[a-z]',
    '\u00B7',
    '[\u00C0-\u00D6]',
    '[\u00D8-\u00F6]',
    '[\u00F8-\u037D]',
    '[\u037F-\u1FFF]',
    '[\u200C-\u200D]',
    '[\u203F-\u2040]',
    '[\u2070-\u218F]',
    '[\u2C00-\u2FEF]',
    '[\u3001-\uD7FF]',
    '[\uF900-\uFDCF]',
    '[\uFDF0-\uFFFD]',
    '[\uD800-\uDBFF][\uDC00-\uDFFF]',
].join('|');
function htmlSpec(tag) {
    tag = tag.toLowerCase();
    const spec = html_spec_1.default.specs.find(spec => spec.name === tag);
    return spec || null;
}
exports.htmlSpec = htmlSpec;
function isValidAttr(name, value, isDynamicValue, node, attrSpecs) {
    let invalid = false;
    const spec = attrSpecs.find(s => s.name === name);
    invalid = type_check_1.typeCheck(name, value, false, spec);
    if (!invalid && spec && spec.condition && !node.hasSpreadAttr && !attrMatches(node, spec.condition)) {
        invalid = {
            invalidType: 'non-existent',
            message: `The "${name}" attribute is not allowed`,
        };
    }
    if (invalid && invalid.invalidType === 'invalid-value' && isDynamicValue) {
        invalid = false;
    }
    return invalid;
}
exports.isValidAttr = isValidAttr;
function ariaSpec() {
    const roles = html_spec_1.default.def['#roles'];
    const ariaAttrs = html_spec_1.default.def['#ariaAttrs'];
    return {
        roles,
        ariaAttrs,
    };
}
exports.ariaSpec = ariaSpec;
function getRoleSpec(roleName) {
    const role = getRoleByName(roleName);
    if (!role) {
        return null;
    }
    const superClassRoles = recursiveTraverseSuperClassRoles(roleName);
    return {
        name: role.name,
        isAbstract: !!role.isAbstract,
        statesAndProps: role.ownedAttribute,
        superClassRoles,
    };
}
exports.getRoleSpec = getRoleSpec;
function getRoleByName(roleName) {
    const roles = html_spec_1.default.def['#roles'];
    const role = roles.find(r => r.name === roleName);
    return role;
}
function getSuperClassRoles(roleName) {
    const role = getRoleByName(roleName);
    return ((role === null || role === void 0 ? void 0 : role.generalization.map(roleName => getRoleByName(roleName)).filter((role) => !!role)) || null);
}
function recursiveTraverseSuperClassRoles(roleName) {
    const roles = [];
    const superClassRoles = getSuperClassRoles(roleName);
    if (superClassRoles) {
        roles.push(...superClassRoles);
        for (const superClassRole of superClassRoles) {
            const ancestorRoles = recursiveTraverseSuperClassRoles(superClassRole.name);
            roles.push(...ancestorRoles);
        }
    }
    return roles;
}
/**
 * Getting permitted ARIA roles.
 *
 * - If an array, it is role list.
 * - If `true`, this mean is "Any".
 * - If `false`, this mean is "No".
 */
function getPermittedRoles(el) {
    var _a;
    const implicitRole = getImplicitRole(el);
    const spec = (_a = htmlSpec(el.nodeName)) === null || _a === void 0 ? void 0 : _a.permittedRoles;
    if (!spec) {
        return true;
    }
    if (spec.conditions) {
        for (const { condition, roles } of spec.conditions) {
            if (el.matches(condition)) {
                return mergeRoleList(implicitRole, roles);
            }
        }
    }
    if (implicitRole && Array.isArray(spec.roles)) {
        return [implicitRole, ...spec.roles];
    }
    if (implicitRole && spec.roles === false) {
        return [implicitRole];
    }
    return mergeRoleList(implicitRole, spec.roles);
}
exports.getPermittedRoles = getPermittedRoles;
function mergeRoleList(implicitRole, permittedRoles) {
    if (implicitRole && Array.isArray(permittedRoles)) {
        return [implicitRole, ...permittedRoles];
    }
    if (implicitRole && permittedRoles === false) {
        return [implicitRole];
    }
    return permittedRoles;
}
function getImplicitRole(el) {
    var _a;
    const implicitRole = (_a = htmlSpec(el.nodeName)) === null || _a === void 0 ? void 0 : _a.implicitRole;
    if (!implicitRole) {
        return false;
    }
    if (implicitRole.conditions) {
        for (const { condition, role } of implicitRole.conditions) {
            if (el.matches(condition)) {
                return role;
            }
        }
    }
    return implicitRole.role;
}
exports.getImplicitRole = getImplicitRole;
function getComputedRole(el) {
    const roleAttrTokens = el.getAttributeToken('role');
    const roleAttr = roleAttrTokens[0];
    if (roleAttr) {
        const roleName = roleAttr.getValue().potential.trim().toLowerCase();
        return {
            name: roleName,
            isImplicit: false,
        };
    }
    const implicitRole = getImplicitRole(el);
    if (implicitRole) {
        return {
            name: implicitRole,
            isImplicit: true,
        };
    }
    return null;
}
exports.getComputedRole = getComputedRole;
/**
 *
 * @see https://www.w3.org/TR/wai-aria-1.2/#propcharacteristic_value
 *
 * @param type
 * @param value
 * @param tokenEnum
 */
function checkAriaValue(type, value, tokenEnum) {
    switch (type) {
        case 'token': {
            return tokenEnum.includes(value);
        }
        case 'token list': {
            const list = value.split(/\s+/g).map(s => s.trim());
            return list.every(token => tokenEnum.includes(token));
        }
        case 'string':
        case 'ID reference':
        case 'ID reference list': {
            return true;
        }
        case 'true/false': {
            return ['true', 'false'].includes(value);
        }
        case 'tristate': {
            return ['mixed', 'true', 'false', 'undefined'].includes(value);
        }
        case 'true/false/undefined': {
            return ['true', 'false', 'undefined'].includes(value);
        }
        case 'integer': {
            return parseInt(value).toString() === value;
        }
        case 'number': {
            return parseFloat(value).toString() === value;
        }
    }
    // For skipping checking
    return true;
}
exports.checkAriaValue = checkAriaValue;
function checkAria(attrName, currentValue, role) {
    const ariaAttrs = html_spec_1.default.def['#ariaAttrs'];
    const aria = ariaAttrs.find(a => a.name === attrName);
    if (!aria) {
        return {
            currentValue,
            // For skipping checking
            isValid: true,
        };
    }
    let valueType = aria.value;
    if (role && aria.conditionalValue) {
        for (const cond of aria.conditionalValue) {
            if (cond.role.includes(role)) {
                valueType = cond.value;
                break;
            }
        }
    }
    const isValid = checkAriaValue(valueType, currentValue, aria.enum);
    return Object.assign(Object.assign({}, aria), { currentValue,
        isValid });
}
exports.checkAria = checkAria;
