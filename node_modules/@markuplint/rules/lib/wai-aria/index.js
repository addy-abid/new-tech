"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_core_1 = require("@markuplint/ml-core");
const helpers_1 = require("../helpers");
exports.default = ml_core_1.createRule({
    name: 'wai-aria',
    defaultLevel: 'error',
    defaultValue: true,
    defaultOptions: {
        checkingValue: true,
        checkingDeprecatedProps: true,
        permittedAriaRoles: true,
        disallowSetImplicitRole: true,
        disallowSetImplicitProps: true,
        disallowDefaultValue: false,
    },
    async verify(document, translate) {
        const reports = [];
        await document.walkOn('Element', async (node) => {
            const attrSpecs = helpers_1.getAttrSpecs(node.nodeName, document.specs);
            const html = helpers_1.htmlSpec(node.nodeName);
            const { roles, ariaAttrs } = helpers_1.ariaSpec();
            if (!html || !attrSpecs) {
                return;
            }
            const roleAttrTokens = node.getAttributeToken('role');
            const roleAttr = roleAttrTokens[0];
            // Roles in the spec
            if (roleAttr) {
                const value = roleAttr.getValue().potential.trim().toLowerCase();
                const existedRole = roles.find(role => role.name === value);
                if (!existedRole) {
                    // Not exist
                    reports.push({
                        severity: node.rule.severity,
                        message: `This "${value}" role does not exist in WAI-ARIA.`,
                        line: roleAttr.startLine,
                        col: roleAttr.startCol,
                        raw: roleAttr.raw,
                    });
                }
                else if (existedRole.isAbstract) {
                    // Abstract role
                    reports.push({
                        severity: node.rule.severity,
                        message: `This "${value}" role is the abstract role.`,
                        line: roleAttr.startLine,
                        col: roleAttr.startCol,
                        raw: roleAttr.raw,
                    });
                }
                // Set the implicit role explicitly
                if (node.rule.option.disallowSetImplicitRole) {
                    const implictRole = helpers_1.getImplicitRole(node);
                    if (implictRole && implictRole === value) {
                        // Abstract role
                        reports.push({
                            severity: node.rule.severity,
                            message: `Don't set the implicit role explicitly because the "${value}" role is the implicit role of the ${node.nodeName} element.`,
                            line: roleAttr.startLine,
                            col: roleAttr.startCol,
                            raw: roleAttr.raw,
                        });
                    }
                }
                // Permitted ARIA Roles
                if (node.rule.option.permittedAriaRoles) {
                    const permittedRoles = helpers_1.getPermittedRoles(node);
                    if (permittedRoles === false) {
                        reports.push({
                            severity: node.rule.severity,
                            message: `The ARIA Role of the ${node.nodeName} element cannot overwrite according to ARIA in HTML spec.`,
                            line: roleAttr.startLine,
                            col: roleAttr.startCol,
                            raw: roleAttr.raw,
                        });
                    }
                    else if (Array.isArray(permittedRoles) && !permittedRoles.includes(value)) {
                        reports.push({
                            severity: node.rule.severity,
                            message: `The ARIA Role of the ${node.nodeName} element cannot overwrite "${value}" according to ARIA in HTML spec.`,
                            line: roleAttr.startLine,
                            col: roleAttr.startCol,
                            raw: roleAttr.raw,
                        });
                    }
                }
            }
            const computedRole = helpers_1.getComputedRole(node);
            if (computedRole) {
                const role = helpers_1.getRoleSpec(computedRole.name);
                if (role) {
                    // Checking aria-* on the role
                    for (const attr of node.attributes) {
                        const attrName = attr.getName().potential.trim().toLowerCase();
                        if (/^aria-/i.test(attrName)) {
                            const statesAndProp = role.statesAndProps.find(s => s.name === attrName);
                            if (statesAndProp) {
                                if (node.rule.option.checkingDeprecatedProps && statesAndProp.deprecated) {
                                    reports.push({
                                        severity: node.rule.severity,
                                        message: `The ${attrName} state/property is deprecated on the ${role.name} role.`,
                                        line: attr.startLine,
                                        col: attr.startCol,
                                        raw: attr.raw,
                                    });
                                }
                            }
                            else {
                                reports.push({
                                    severity: node.rule.severity,
                                    message: `Cannot use the ${attrName} state/property on the ${role.name} role.`,
                                    line: attr.startLine,
                                    col: attr.startCol,
                                    raw: attr.raw,
                                });
                            }
                        }
                    }
                    // Checing required props
                    if (!computedRole.isImplicit) {
                        const requiredProps = role.statesAndProps.filter(s => s.required).map(s => s.name);
                        for (const requiredProp of requiredProps) {
                            const has = node.attributes.some(attr => {
                                const attrName = attr.getName().potential.trim().toLowerCase();
                                return attrName === requiredProp;
                            });
                            if (!has) {
                                reports.push({
                                    severity: node.rule.severity,
                                    message: `The ${requiredProp} state/property is required on the ${role.name} role.`,
                                    line: node.startLine,
                                    col: node.startCol,
                                    raw: node.raw,
                                });
                            }
                        }
                    }
                }
            }
            else {
                // No role element
                const { ariaAttrs } = helpers_1.ariaSpec();
                for (const attr of node.attributes) {
                    const attrName = attr.getName().potential.trim().toLowerCase();
                    if (/^aria-/i.test(attrName)) {
                        const ariaAttr = ariaAttrs.find(attr => attr.name === attrName);
                        if (ariaAttr && !ariaAttr.isGlobal) {
                            reports.push({
                                severity: node.rule.severity,
                                message: `The ${attrName} is not global state/property.`,
                                line: attr.startLine,
                                col: attr.startCol,
                                raw: attr.raw,
                            });
                        }
                    }
                }
            }
            for (const attr of node.attributes) {
                if (attr.attrType === 'html-attr' && attr.isDynamicValue) {
                    continue;
                }
                const attrName = attr.getName().potential.trim().toLowerCase();
                if (/^aria-/i.test(attrName)) {
                    const value = attr.getValue().potential.trim().toLowerCase();
                    const propSpec = ariaAttrs.find(p => p.name === attrName);
                    // Checking ARIA Value
                    if (node.rule.option.checkingValue) {
                        const result = helpers_1.checkAria(attrName, value, computedRole === null || computedRole === void 0 ? void 0 : computedRole.name);
                        if (!result.isValid) {
                            reports.push({
                                severity: node.rule.severity,
                                message: `The "${value}" is disallowed in the ${attrName} state/property.` +
                                    ('enum' in result && result.enum.length
                                        ? ` Allow values are ${result.enum.join(', ')}.`
                                        : ''),
                                line: attr.startLine,
                                col: attr.startCol,
                                raw: attr.raw,
                            });
                        }
                    }
                    // Checking implicit props
                    if (node.rule.option.disallowSetImplicitProps) {
                        if (propSpec && propSpec.equivalentHtmlAttrs) {
                            for (const equivalentHtmlAttr of propSpec.equivalentHtmlAttrs) {
                                const htmlAttrSpec = attrSpecs.find(a => a.name === equivalentHtmlAttr.htmlAttrName);
                                const isValid = helpers_1.isValidAttr(equivalentHtmlAttr.htmlAttrName, equivalentHtmlAttr.value || '', false, node, attrSpecs);
                                if (isValid && isValid.invalidType === 'non-existent') {
                                    continue;
                                }
                                if (node.hasAttribute(equivalentHtmlAttr.htmlAttrName)) {
                                    const targetAttrValue = node.getAttribute(equivalentHtmlAttr.htmlAttrName);
                                    if ((equivalentHtmlAttr.value == null && targetAttrValue === value) ||
                                        equivalentHtmlAttr.value === value) {
                                        reports.push({
                                            severity: node.rule.severity,
                                            message: `Has the ${equivalentHtmlAttr.htmlAttrName} attribute that has equivalent semantic.`,
                                            line: attr.startLine,
                                            col: attr.startCol,
                                            raw: attr.raw,
                                        });
                                        continue;
                                    }
                                    if ((htmlAttrSpec === null || htmlAttrSpec === void 0 ? void 0 : htmlAttrSpec.type) === 'Boolean' && value !== 'false') {
                                        continue;
                                    }
                                    reports.push({
                                        severity: node.rule.severity,
                                        message: `Can be different from the value of the ${equivalentHtmlAttr.htmlAttrName} attribute.`,
                                        line: attr.startLine,
                                        col: attr.startCol,
                                        raw: attr.raw,
                                    });
                                }
                                else if (value === 'true') {
                                    if (!equivalentHtmlAttr.isNotStrictEquivalent && (htmlAttrSpec === null || htmlAttrSpec === void 0 ? void 0 : htmlAttrSpec.type) === 'Boolean') {
                                        reports.push({
                                            severity: node.rule.severity,
                                            message: `Can be in opposition to the value of the unset ${equivalentHtmlAttr.htmlAttrName} attribute.`,
                                            line: attr.startLine,
                                            col: attr.startCol,
                                            raw: attr.raw,
                                        });
                                    }
                                }
                            }
                        }
                    }
                    // Default value
                    if (node.rule.option.disallowDefaultValue && propSpec && propSpec.defaultValue === value) {
                        reports.push({
                            severity: node.rule.severity,
                            message: 'It is default value',
                            line: attr.startLine,
                            col: attr.startCol,
                            raw: attr.raw,
                        });
                    }
                }
            }
        });
        return reports;
    },
});
