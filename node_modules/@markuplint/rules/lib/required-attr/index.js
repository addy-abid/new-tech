"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_core_1 = require("@markuplint/ml-core");
const helpers_1 = require("../helpers");
exports.default = ml_core_1.createRule({
    name: 'required-attr',
    defaultLevel: 'error',
    defaultValue: [],
    defaultOptions: null,
    async verify(document, translate) {
        const reports = [];
        await document.walkOn('Element', async (node) => {
            if (node.hasSpreadAttr) {
                return;
            }
            const customRequiredAttrs = typeof node.rule.value === 'string' ? [node.rule.value] : node.rule.value;
            const attrSpec = helpers_1.getAttrSpecs(node.nodeName, document.specs);
            const attributeSpecs = attrSpec
                ? attrSpec.map(attr => {
                    const required = customRequiredAttrs.includes(attr.name);
                    if (required) {
                        return Object.assign(Object.assign({}, attr), { required: true });
                    }
                    return attr;
                })
                : customRequiredAttrs.map(attr => ({
                    name: attr,
                    required: true,
                    requiredEither: undefined,
                    condition: undefined,
                }));
            for (const spec of attributeSpecs) {
                const didntHave = !node.hasAttribute(spec.name);
                let invalid = false;
                if (spec.requiredEither) {
                    const candidate = [...spec.requiredEither, spec.name];
                    invalid = !candidate.some(attrName => node.hasAttribute(attrName));
                }
                else if (spec.required === true) {
                    invalid = helpers_1.attrMatches(node, spec.condition) && didntHave;
                }
                else if (spec.required) {
                    if (spec.required.ancestor) {
                        const ancestors = spec.required.ancestor.split(',').map(a => a.trim());
                        invalid = ancestors.some(a => node.closest(a)) && didntHave;
                    }
                }
                if (invalid) {
                    const message = translate('Required {0} on {1}', `'${spec.name}'`, `'<${node.nodeName}>'`);
                    reports.push({
                        severity: node.rule.severity,
                        message,
                        line: node.startLine,
                        col: node.startCol,
                        raw: node.raw,
                    });
                }
            }
        });
        return reports;
    },
});
