"use strict";
var _MLDOMNode_doc, _MLDOMNode_prevToken, _MLDOMNode_indentaion;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const indentation_1 = tslib_1.__importDefault(require("./indentation"));
const token_1 = tslib_1.__importDefault(require("./token"));
class MLDOMNode extends token_1.default {
    constructor(astNode, document) {
        super(astNode);
        this.type = 'Node';
        _MLDOMNode_doc.set(this, void 0);
        /**
         * prevToken cache props
         */
        _MLDOMNode_prevToken.set(this, void 0);
        /**
         * indentation cache props
         */
        _MLDOMNode_indentaion.set(this, void 0);
        this._astToken = astNode;
        tslib_1.__classPrivateFieldSet(this, _MLDOMNode_doc, document, "f");
        tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeStore.setNode(astNode, this);
    }
    get parentNode() {
        if (!this._astToken.parentNode) {
            return null;
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeStore.getNode(this._astToken.parentNode);
    }
    get prevNode() {
        if (!this._astToken.prevNode) {
            return null;
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeStore.getNode(this._astToken.prevNode);
    }
    get nextNode() {
        if (!this._astToken.nextNode) {
            return null;
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeStore.getNode(this._astToken.nextNode);
    }
    get syntaxicalParentNode() {
        let parentNode = this.parentNode;
        while (parentNode && parentNode.type === 'OmittedElement') {
            parentNode = parentNode.parentNode;
        }
        return parentNode;
    }
    get prevToken() {
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMNode_prevToken, "f") !== undefined) {
            return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_prevToken, "f");
        }
        let index = -1;
        for (let i = 0; i < tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeList.length; i++) {
            const node = tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeList[i];
            if (!node) {
                continue;
            }
            if (node.type === 'OmittedElement') {
                continue;
            }
            if (node.uuid === this.uuid) {
                index = i;
                break;
            }
        }
        if (index === -1) {
            tslib_1.__classPrivateFieldSet(this, _MLDOMNode_prevToken, null, "f");
            return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_prevToken, "f");
        }
        tslib_1.__classPrivateFieldSet(this, _MLDOMNode_prevToken, tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeList[index - 1] || null, "f");
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_prevToken, "f");
    }
    get nodeStore() {
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").nodeStore;
    }
    toString() {
        return this.raw;
    }
    is(type) {
        return this.type === type;
    }
    get indentation() {
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMNode_indentaion, "f") !== undefined) {
            return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_indentaion, "f");
        }
        const prevToken = this.prevToken;
        if (!prevToken) {
            return null;
        }
        if (prevToken.type !== 'Text') {
            return null;
        }
        // One or more newlines and zero or more spaces or tabs.
        // Or, If textNode is first token and that is filled spaces, tabs and newlines only.
        const matched = prevToken._isFirstToken()
            ? prevToken.raw.match(/^(?:[ \t]*\r?\n)*([ \t]*)$/)
            : prevToken.raw.match(/\r?\n([ \t]*)$/);
        // console.log({ [`${this}`]: matched, _: prevToken.raw, f: prevToken._isFirstToken() });
        if (matched) {
            // Spaces will include empty string.
            const spaces = matched[1];
            if (spaces != null) {
                tslib_1.__classPrivateFieldSet(this, _MLDOMNode_indentaion, new indentation_1.default(prevToken, spaces, this.startLine, this), "f");
                return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_indentaion, "f");
            }
        }
        tslib_1.__classPrivateFieldSet(this, _MLDOMNode_indentaion, null, "f");
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_indentaion, "f");
    }
    get rule() {
        if (!tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").currentRule) {
            throw new Error('Invalid call.');
        }
        const name = tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").currentRule.name;
        // @ts-ignore
        const ruleConfig = this.rules[name];
        if (ruleConfig == null) {
            throw new Error('Invalid call "rule" property.');
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMNode_doc, "f").currentRule.optimizeOption(ruleConfig);
    }
    _isFirstToken() {
        return !this.prevToken;
    }
}
exports.default = MLDOMNode;
_MLDOMNode_doc = new WeakMap(), _MLDOMNode_prevToken = new WeakMap(), _MLDOMNode_indentaion = new WeakMap();
