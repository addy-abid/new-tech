"use strict";
var _MLDOMElement_tagOpenChar, _MLDOMElement_tagCloseChar, _MLDOMElement_fixedNodeName;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _1 = require("./");
const helper_1 = require("../helper");
const preprocessor_specific_attribute_1 = tslib_1.__importDefault(require("./preprocessor-specific-attribute"));
const string_splice_1 = require("../../utils/string-splice");
const walkers_1 = require("../helper/walkers");
class MLDOMElement extends _1.MLDOMNode {
    constructor(astNode, document) {
        super(astNode, document);
        this.type = 'Element';
        this.ownModels = new Set();
        this.childModels = new Set();
        this.descendantModels = new Set();
        _MLDOMElement_tagOpenChar.set(this, void 0);
        _MLDOMElement_tagCloseChar.set(this, void 0);
        _MLDOMElement_fixedNodeName.set(this, void 0);
        this.nodeName = astNode.nodeName;
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_fixedNodeName, astNode.nodeName, "f");
        this.attributes = astNode.attributes.map(attr => attr.type === 'html-attr' ? new _1.MLDOMAttribute(attr) : new preprocessor_specific_attribute_1.default(attr));
        this.hasSpreadAttr = astNode.hasSpreadAttr;
        this.selfClosingSolidus = astNode.selfClosingSolidus ? new _1.MLDOMToken(astNode.selfClosingSolidus) : null;
        this.endSpace = astNode.endSpace ? new _1.MLDOMToken(astNode.endSpace) : null;
        this.namespaceURI = astNode.namespace;
        this.isForeignElement = this.namespaceURI !== 'http://www.w3.org/1999/xhtml';
        this.closeTag = astNode.pearNode ? helper_1.createNode(astNode.pearNode, document, this) : null;
        this.isCustomElement = astNode.isCustomElement;
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_tagOpenChar, astNode.tagOpenChar, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_tagCloseChar, astNode.tagCloseChar, "f");
    }
    get raw() {
        let fixed = this.originRaw;
        let gap = 0;
        if (this.nodeName !== tslib_1.__classPrivateFieldGet(this, _MLDOMElement_fixedNodeName, "f")) {
            fixed = string_splice_1.stringSplice(fixed, tslib_1.__classPrivateFieldGet(this, _MLDOMElement_tagOpenChar, "f").length, this.nodeName.length, tslib_1.__classPrivateFieldGet(this, _MLDOMElement_fixedNodeName, "f"));
            gap = gap + tslib_1.__classPrivateFieldGet(this, _MLDOMElement_fixedNodeName, "f").length - this.nodeName.length;
        }
        for (const attr of this.attributes) {
            const startOffset = (attr.attrType === 'html-attr' ? attr.spacesBeforeName.startOffset : attr.startOffset) -
                this.startOffset;
            const fixedAttr = attr.toString();
            if (attr.originRaw !== fixedAttr) {
                fixed = string_splice_1.stringSplice(fixed, startOffset + gap, attr.originRaw.length, fixedAttr);
                gap = gap + fixedAttr.length - attr.originRaw.length;
            }
        }
        return fixed;
    }
    get childNodes() {
        const astChildren = this._astToken.childNodes || [];
        return astChildren.map(node => this.nodeStore.getNode(node));
    }
    querySelectorAll(selector) {
        const matchedNodes = [];
        walkers_1.syncWalk(this.childNodes, node => {
            if (node.type === 'Element' && node.matches(selector)) {
                matchedNodes.push(node);
            }
            if (selector === '#text' && node.type === 'Text' && !node.isWhitespace()) {
                matchedNodes.push(node);
            }
        });
        return matchedNodes;
    }
    closest(selector) {
        let el = this;
        do {
            if (el.matches(selector)) {
                return el;
            }
            el = el.parentNode;
        } while (el !== null && el.type === 'Element');
        return null;
    }
    getAttributeToken(attrName) {
        const attrs = [];
        attrName = attrName.toLowerCase();
        for (const attr of this.attributes) {
            if (attr.potentialName === attrName) {
                attrs.push(attr);
            }
        }
        return attrs;
    }
    getAttribute(attrName) {
        attrName = attrName.toLowerCase();
        for (const attr of this.attributes) {
            if (attr.potentialName === attrName) {
                if (attr.attrType === 'html-attr') {
                    return attr.value ? attr.value.raw : null;
                }
                else {
                    return attr.potentialValue;
                }
            }
        }
        return null;
    }
    hasAttribute(attrName) {
        return !!this.getAttributeToken(attrName).length;
    }
    matches(selector) {
        // @ts-ignore TODO: To improvement testable object
        return helper_1.createSelector(selector).match(this);
    }
    fixNodeName(name) {
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_fixedNodeName, name, "f");
    }
    getChildElementsAndTextNodeWithoutWhitespaces() {
        const filteredNodes = [];
        this.childNodes.forEach(node => {
            if (node.type === 'Element') {
                filteredNodes.push(node);
            }
            if (node.type === 'Text' && !node.isWhitespace()) {
                filteredNodes.push(node);
            }
            if (node.type === 'OmittedElement') {
                const children = node.getChildElementsAndTextNodeWithoutWhitespaces();
                filteredNodes.push(...children);
            }
        });
        return filteredNodes;
    }
    /**
     * This element has "Preprocessor Specific Block". In other words, Its children are potentially mutable.
     */
    hasMutableChildren() {
        return this.childNodes.some(node => node.type === 'PSBlock');
    }
    isDescendantByUUIDList(uuidList) {
        let el = this.parentNode;
        if (el === null) {
            return false;
        }
        do {
            if (uuidList.includes(el.uuid)) {
                return true;
            }
            el = el.parentNode;
        } while (el !== null && el.type === 'Element');
        return false;
    }
    getNameLocation() {
        return {
            offset: this.startOffset,
            line: this.startLine,
            col: this.startCol + tslib_1.__classPrivateFieldGet(this, _MLDOMElement_tagOpenChar, "f").length,
        };
    }
    get classList() {
        const classList = [];
        const classAttrs = this.getAttributeToken('class');
        for (const classAttr of classAttrs) {
            const value = classAttr.attrType === 'html-attr' ? classAttr.value.raw : classAttr.potentialValue;
            classList.push(...value
                .split(/\s+/g)
                .map(c => c.trim())
                .filter(c => c));
        }
        return classList;
    }
    get id() {
        return this.getAttribute('id') || '';
    }
}
exports.default = MLDOMElement;
_MLDOMElement_tagOpenChar = new WeakMap(), _MLDOMElement_tagCloseChar = new WeakMap(), _MLDOMElement_fixedNodeName = new WeakMap();
