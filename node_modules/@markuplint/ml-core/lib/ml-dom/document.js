"use strict";
var _MLDOMDocument_filename;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ml_spec_1 = require("@markuplint/ml-spec");
const ml_ast_1 = require("@markuplint/ml-ast");
const tokens_1 = require("./tokens");
const helper_1 = require("./helper");
const walkers_1 = require("./helper/walkers");
/**
 * markuplint DOM Document
 */
class MLDOMDocument {
    /**
     *
     * @param ast node list of markuplint AST
     * @param ruleset ruleset object
     */
    constructor(ast, ruleset, schemas, filename) {
        /**
         *
         */
        this.currentRule = null;
        /**
         *
         */
        this.nodeStore = new helper_1.NodeStore();
        _MLDOMDocument_filename.set(this, void 0);
        // console.log(ast.nodeList.map((n, i) => `${i}: ${n.uuid} "${n.raw.trim()}"(${n.type})`));
        this.nodeList = Object.freeze(ast.nodeList.map(astNode => {
            if (astNode.type === ml_ast_1.MLASTNodeType.EndTag) {
                return this.nodeStore.getNode(astNode);
            }
            return helper_1.createNode(astNode, this);
        }));
        this.isFragment = ast.isFragment;
        this.specs = ml_spec_1.getSpec(schemas);
        tslib_1.__classPrivateFieldSet(this, _MLDOMDocument_filename, filename, "f");
        this._init(ruleset);
    }
    /**
     * It could be used in rule, make sure it is immutable
     */
    get filename() {
        return tslib_1.__classPrivateFieldGet(this, _MLDOMDocument_filename, "f");
    }
    get doctype() {
        for (const node of this.nodeList) {
            if (node instanceof tokens_1.MLDOMDoctype) {
                return node;
            }
        }
        return null;
    }
    get tree() {
        const treeRoots = [];
        let traversalNode = this.nodeList[0];
        while (traversalNode) {
            treeRoots.push(traversalNode);
            traversalNode = traversalNode.nextNode;
        }
        return treeRoots;
    }
    walk(walker) {
        /**
         * The following pattern is used to ensure that all rules run sequentially,
         * no matter it runs asynchronously or synchronously.
         */
        let _resolve;
        let _reject;
        const promise = new Promise((resolve, reject) => {
            _resolve = resolve;
            _reject = reject;
        });
        const loop = (index = 0) => {
            if (index >= this.nodeList.length) {
                _resolve();
                return;
            }
            const node = this.nodeList[index];
            const result = walker(node);
            if (result instanceof Promise) {
                result.then(() => loop(index + 1)).catch(_reject);
            }
            else {
                loop(index + 1);
            }
        };
        loop();
        return promise;
    }
    walkOn(type, walker, skipWhenRuleIsDisabled = true) {
        return this.walk(node => {
            if (node instanceof tokens_1.MLDOMNode) {
                if (skipWhenRuleIsDisabled && node.rule.disabled) {
                    return;
                }
                if (node.is(type)) {
                    return walker(node);
                }
            }
        });
    }
    setRule(rule) {
        this.currentRule = rule;
    }
    matchNodes(query) {
        return this.nodeList.filter((node) => node.type === 'Element' && node.matches(query));
    }
    toString() {
        const html = [];
        for (const node of this.nodeList) {
            html.push(node.raw);
        }
        return html.join('');
    }
    _init(ruleset) {
        // add rules to node
        for (const node of this.nodeList) {
            // global rules
            for (const ruleName of Object.keys(ruleset.rules)) {
                const rule = ruleset.rules[ruleName];
                node.rules[ruleName] = rule;
            }
            if (node.type !== 'Element' && node.type !== 'ElementCloseTag') {
                continue;
            }
            const selectorTarget = node.type === 'Element' ? node : node.startTag;
            // node specs and special rules for node by selector
            for (const nodeRule of ruleset.nodeRules) {
                if (!nodeRule.rules) {
                    continue;
                }
                const selector = nodeRule.selector || nodeRule.tagName;
                if (!selector) {
                    continue;
                }
                const matched = selectorTarget.matches(selector);
                if (!matched) {
                    continue;
                }
                // special rules
                for (const ruleName of Object.keys(nodeRule.rules)) {
                    const rule = nodeRule.rules[ruleName];
                    node.rules[ruleName] = rule;
                }
            }
        }
        // overwrite rule to child node
        for (const nodeRule of ruleset.childNodeRules) {
            if (!nodeRule.rules || !nodeRule.selector) {
                break;
            }
            for (const ruleName of Object.keys(nodeRule.rules)) {
                const rule = nodeRule.rules[ruleName];
                for (const node of this.nodeList) {
                    if (node.type !== 'Element') {
                        continue;
                    }
                    if (node.matches(nodeRule.selector)) {
                        if (nodeRule.inheritance) {
                            walkers_1.syncWalk(node.childNodes, childNode => {
                                childNode.rules[ruleName] = rule;
                            });
                        }
                        else {
                            for (const childNode of node.childNodes) {
                                childNode.rules[ruleName] = rule;
                            }
                        }
                    }
                }
            }
        }
    }
}
exports.default = MLDOMDocument;
_MLDOMDocument_filename = new WeakMap();
