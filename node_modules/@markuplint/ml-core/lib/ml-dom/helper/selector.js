"use strict";
var _Selector_rawSelector, _Selector_ruleset;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSelector = void 0;
const tslib_1 = require("tslib");
const css_selector_parser_1 = require("css-selector-parser");
class Selector {
    constructor(selector) {
        _Selector_rawSelector.set(this, void 0);
        _Selector_ruleset.set(this, void 0);
        const selectorParser = new css_selector_parser_1.CssSelectorParser();
        selectorParser.registerSelectorPseudos('not');
        selectorParser.registerNestingOperators('>');
        selectorParser.registerAttrEqualityMods('~', '^', '$', '*', '|');
        tslib_1.__classPrivateFieldSet(this, _Selector_rawSelector, selector, "f");
        tslib_1.__classPrivateFieldSet(this, _Selector_ruleset, selectorParser.parse(selector), "f");
    }
    match(element) {
        return match(element, tslib_1.__classPrivateFieldGet(this, _Selector_ruleset, "f"), tslib_1.__classPrivateFieldGet(this, _Selector_rawSelector, "f"));
    }
}
_Selector_rawSelector = new WeakMap(), _Selector_ruleset = new WeakMap();
function match(element, ruleset, rawSelector) {
    const rules = ruleset.type === 'selectors' ? ruleset.selectors.map(ruleSet => ruleSet.rule) : [ruleset.rule];
    const orMatch = [];
    for (const rule of rules) {
        const andMatch = [];
        if (rule.id) {
            andMatch.push(rule.id === element.id);
        }
        if (rule.classNames) {
            andMatch.push(rule.classNames.every(className => {
                var _a;
                return Array.isArray(element.classList)
                    ? element.classList.includes(className)
                    : (_a = element.classList) === null || _a === void 0 ? void 0 : _a.contains(className);
            }));
        }
        if (rule.tagName) {
            if (rule.tagName === '*') {
                andMatch.push(true);
            }
            else {
                andMatch.push(rule.tagName.toLowerCase() === element.nodeName.toLowerCase());
            }
        }
        if (rule.attrs && element.getAttribute) {
            for (const ruleAttr of rule.attrs) {
                const value = element.getAttribute(ruleAttr.name);
                if (value == null) {
                    andMatch.push(false);
                    continue;
                }
                if (!('value' in ruleAttr && 'operator' in ruleAttr)) {
                    andMatch.push(true);
                    continue;
                }
                switch (ruleAttr.operator) {
                    case '=': {
                        // if (ruleAttr.ignoreCase) {
                        // 	andMatch.push(value === ruleAttr.value);
                        // } else {
                        // 	andMatch.push(value.toLowerCase() === ruleAttr.value.toLowerCase());
                        // }
                        andMatch.push(value === ruleAttr.value);
                        break;
                    }
                    case '~=': {
                        throw new Error(`Unsupport "[attr~=val]" attribute selector in "${rawSelector}"`);
                    }
                    case '^=': {
                        // const re = new RegExp(`^${ruleAttr.value}`, ruleAttr.ignoreCase ? 'i' : undefined);
                        const re = new RegExp(`^${ruleAttr.value}`);
                        andMatch.push(re.test(value));
                        break;
                    }
                    case '$=': {
                        // const re = new RegExp(`${ruleAttr.value}$`, ruleAttr.ignoreCase ? 'i' : undefined);
                        const re = new RegExp(`${ruleAttr.value}$`);
                        andMatch.push(re.test(value));
                        break;
                    }
                    case '*=': {
                        // const re = new RegExp(ruleAttr.value, ruleAttr.ignoreCase ? 'i' : undefined);
                        const re = new RegExp(ruleAttr.value);
                        andMatch.push(re.test(value));
                        break;
                    }
                    // case '!=': {
                    // 	throw new Error(`Unsupport "[attr!=val]" attribute selector in "${rawSelector}"`);
                    // }
                    case '|=': {
                        throw new Error(`Unsupport "[attr|=val]" attribute selector in "${rawSelector}"`);
                    }
                }
                break;
            }
        }
        if (rule.pseudos) {
            for (const pseudo of rule.pseudos) {
                switch (pseudo.name) {
                    case 'not': {
                        if (pseudo.valueType !== 'selector') {
                            throw new Error(`Unexpected parameters in "not" pseudo selector in "${rawSelector}"`);
                        }
                        andMatch.push(!match(element, pseudo.value, rawSelector));
                        break;
                    }
                    case 'root': {
                        andMatch.push(!element.parentNode);
                        break;
                    }
                    case 'has': {
                        let childSelector;
                        let useChildCombinator = false;
                        if (pseudo.valueType !== 'selector') {
                            const selectorParser = new css_selector_parser_1.CssSelectorParser();
                            /**
                             * The issue.
                             * @see https://github.com/mdevils/css-selector-parser/issues/21
                             */
                            if (/^>/.test(pseudo.value.trim())) {
                                pseudo.value = pseudo.value.trim().replace(/^>/, '');
                                useChildCombinator = true;
                            }
                            childSelector = selectorParser.parse(pseudo.value);
                            // throw new Error(`Unexpected parameters in "has" pseudo selector in "${rawSelector}"`);
                        }
                        else {
                            childSelector = pseudo.value;
                        }
                        const nodes = treeToArray(element.childNodes, !useChildCombinator);
                        const has = nodes.some(node => {
                            return match(node, childSelector, rawSelector);
                        });
                        andMatch.push(has);
                        break;
                    }
                    case 'closest': {
                        // TODO: To impliment
                        break;
                    }
                    default: {
                        throw new Error(`Unsupport "${pseudo.name}" pseudo selector in "${rawSelector}"`);
                    }
                }
            }
        }
        orMatch.push(andMatch.length ? andMatch.every(b => b) : false);
    }
    return orMatch.some(b => b);
}
function createSelector(selector) {
    return new Selector(selector);
}
exports.createSelector = createSelector;
function treeToArray(tree, recursive = true) {
    const array = [];
    for (const node of tree) {
        if ('childNodes' in node) {
            array.push(node);
            if (recursive) {
                array.push(...treeToArray(node.childNodes));
            }
        }
    }
    return array;
}
