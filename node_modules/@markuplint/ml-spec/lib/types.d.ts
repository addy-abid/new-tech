import { ContentModel, PermittedStructuresSchema } from './permitted-structres';
/**
 * markuplit Markup-language spec
 */
export interface MLMLSpec {
    cites: Cites;
    def: SpecDefs;
    specs: ElementSpec[];
}
declare type ExtendedElementSpec = Partial<ElementSpec> & {
    name: ElementSpec['name'];
};
export declare type ExtendedSpec = {
    cites?: Cites;
    def?: Partial<SpecDefs>;
    specs?: ExtendedElementSpec[];
};
/**
 * Reference URLs
 */
export declare type Cites = string[];
export declare type SpecDefs = {
    '#globalAttrs': Attribute[];
    '#roles': ARIRRoleAttribute[];
    '#ariaAttrs': ARIAAttribute[];
    '#contentModels': {
        [model in ContentModel]?: string[];
    };
};
/**
 * Element spec
 */
export declare type ElementSpec = {
    /**
     * Tag name
     */
    name: string;
    /**
     * Reference URL
     */
    cite: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Experimental technology
     */
    experimental?: true;
    /**
     * Obsolete or alternative elements
     */
    obsolete?: true | {
        alt: string;
    };
    /**
     * Deprecated
     */
    deprecated?: true;
    /**
     * Non-standard
     */
    nonStandard?: true;
    /**
     * Element cateogries
     */
    categories: ContentModel[];
    /**
     * Permitted contents and permitted parents
     */
    permittedStructures: PermittedStructuresSchema;
    /**
     * Permitted ARIA roles
     */
    permittedRoles: {
        summary: string;
        roles: PermittedRoles;
        conditions?: {
            condition: string;
            roles: PermittedRoles;
        }[];
    };
    /**
     * Implicit ARIA role
     */
    implicitRole: {
        summary: string;
        role: ImplicitRole;
        conditions?: {
            condition: string;
            role: ImplicitRole;
        }[];
    };
    /**
     * Tag omittion
     */
    omittion: ElementSpecOmittion;
    /**
     * Attributes
     */
    attributes: (Attribute | string)[];
};
/**
 * If `false`, this mean is "No corresponding role".
 */
declare type ImplicitRole = string | false;
/**
 * If `true`, this mean is "Any".
 * If `false`, this mean is "No".
 */
export declare type PermittedRoles = string[] | boolean;
declare type ElementSpecOmittion = false | ElementSpecOmittionTags;
declare type ElementSpecOmittionTags = {
    startTag: boolean | ElementCondition;
    endTag: boolean | ElementCondition;
};
declare type ElementCondition = {
    __WIP__: 'WORK_IN_PROGRESS';
};
export declare type Attribute = {
    name: string;
    type: AttributeType;
    description: string;
    caseSensitive?: true;
    experimental?: true;
    obsolete?: true;
    deprecated?: true;
    nonStandard?: true;
    required?: true | AttributeCondition;
    requiredEither?: string[];
    enum?: string[];
    noUse?: boolean;
    condition?: AttributeCondition;
};
export declare type AttributeCondition = {
    ancestor?: string;
    self?: string | string[];
};
export declare type AttributeType = 'String' | 'NonEmptyString' | 'Boolean' | 'Function' | 'Date' | 'Int' | 'Uint' | 'Float' | 'NonZeroUint' | 'AcceptList' | 'AutoComplete' | 'BCP47' | 'Color' | 'ColSpan' | 'Coords' | 'DateTime' | 'Destination' | 'DOMID' | 'DOMIDList' | 'ItemType' | 'LinkSizes' | 'LinkType' | 'LinkTypeList' | 'MediaQuery' | 'MediaQueryList' | 'MIMEType' | 'ReferrerPolicy' | 'RowSpan' | 'SourceSizeList' | 'SrcSet' | 'TabIndex' | 'Target' | 'URL' | 'URLHash' | 'URLList';
export declare type ARIRRoleAttribute = {
    name: string;
    description: string;
    isAbstract?: true;
    generalization: string[];
    requiredContextRole?: string[];
    accessibleNameRequired: boolean;
    accessibleNameFromContent: boolean;
    accessibleNameProhibited: boolean;
    ownedAttribute: ARIARoleOwnedPropOrState[];
    childrenPresentational?: boolean;
};
export declare type ARIARoleOwnedPropOrState = {
    name: string;
    inherited?: true;
    required?: true;
    deprecated?: true;
    prohibited?: true;
    defaultValue?: boolean | string | number;
};
export declare type ARIAAttribute = {
    name: string;
    type: 'property' | 'state';
    deprecated?: true;
    isGlobal?: true;
    value: ARIAAttributeValue;
    conditionalValue?: {
        role: string[];
        value: ARIAAttributeValue;
    }[];
    enum: string[];
    defaultValue?: string;
    equivalentHtmlAttrs?: EquivalentHtmlAttr[];
    valueDescriptions?: Record<string, string>;
};
export declare type ARIAAttributeValue = 'true/false' | 'tristate' | 'true/false/undefined' | 'ID reference' | 'ID reference list' | 'integer' | 'number' | 'string' | 'token' | 'token list' | 'URI';
export declare type EquivalentHtmlAttr = {
    htmlAttrName: string;
    isNotStrictEquivalent?: true;
    value: string | null;
};
export interface SpecOM {
    [tagName: string]: MLDOMElementSpec;
}
export interface MLDOMElementSpec {
    experimental: boolean;
    obsolete: boolean | string;
    deprecated: boolean;
    nonStandard: boolean;
    categories: ContentModel[];
    permittedStructures: PermittedStructuresSchema;
    attributes: Attribute[];
}
export {};
