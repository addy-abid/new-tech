"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.restoreNode = exports.ignoreBlock = void 0;
const ml_ast_1 = require("@markuplint/ml-ast");
const utils_1 = require("./utils");
const const_1 = require("./const");
function ignoreBlock(source, tags) {
    let replaced = source;
    const stack = [];
    for (const tag of tags) {
        // Replace tags in attributes
        const attr = maskText(prepend(tag.start, '(?<=(?:"|\'))'), append(tag.end, '(?=(?:"|\'))'), replaced, (startTag, taggedCode, endTag) => {
            const mask = const_1.MASK_CHAR.repeat(startTag.length) +
                taggedCode.replace(/[^\n]/g, const_1.MASK_CHAR) +
                const_1.MASK_CHAR.repeat((endTag || '').length);
            return mask;
        });
        replaced = attr.replaced;
        stack.push(...attr.stack.map(res => (Object.assign(Object.assign({}, res), { type: tag.type }))));
        // Replace tags in other nodes
        const text = maskText(tag.start, tag.end, replaced, (startTag, taggedCode, endTag) => {
            const mask = const_1.MASK_CHAR.repeat(startTag.length) +
                taggedCode.replace(/[^\n]/g, const_1.MASK_CHAR) +
                const_1.MASK_CHAR.repeat((endTag || '').length);
            const taggedMask = `<!${mask.slice(2).slice(0, -1)}>`;
            return taggedMask;
        });
        replaced = text.replaced;
        stack.push(...text.stack.map(res => (Object.assign(Object.assign({}, res), { type: tag.type }))));
    }
    stack.sort((a, b) => a.index - b.index);
    return {
        source,
        replaced,
        stack,
    };
}
exports.ignoreBlock = ignoreBlock;
function maskText(start, end, replaced, masking) {
    const stack = [];
    start = removeGlobalOption(start);
    end = removeGlobalOption(end);
    while (start.test(replaced)) {
        const [index, above, startTag, _below] = snap(replaced, start);
        if (!startTag || !_below) {
            continue;
        }
        const [, taggedCode, endTag, below] = snap(_below, end);
        stack.push({
            index,
            startTag,
            taggedCode,
            endTag: endTag || null,
        });
        /**
         * It will not replace line breaks because detects line number.
         */
        replaced = above + masking(startTag, taggedCode, endTag) + (below || '');
    }
    return {
        replaced,
        stack,
    };
}
function restoreNode(nodeList, ignoreBlock) {
    nodeList = nodeList.slice();
    const { source, stack } = ignoreBlock;
    for (const node of nodeList) {
        if (node.type === ml_ast_1.MLASTNodeType.Comment || node.type === ml_ast_1.MLASTNodeType.Text) {
            if (!hasIgnoreBlock(node.raw)) {
                continue;
            }
            const parentNode = node.parentNode;
            const index = nodeList.findIndex(n => n === node);
            const insertList = [];
            let text = node.raw;
            let pointer = 0;
            for (const tag of stack) {
                if (node.startOffset <= tag.index && tag.index < node.endOffset) {
                    const start = tag.index - node.startOffset;
                    const body = tag.startTag + tag.taggedCode + (tag.endTag || '');
                    const above = node.raw.slice(pointer, start);
                    const below = text.slice(above.length + body.length);
                    if (above) {
                        const offset = node.startOffset + pointer;
                        const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = utils_1.sliceFragment(source, offset, offset + above.length);
                        const textNode = Object.assign(Object.assign({}, node), { uuid: utils_1.uuid(), type: ml_ast_1.MLASTNodeType.Text, raw,
                            startOffset,
                            endOffset,
                            startLine,
                            endLine,
                            startCol,
                            endCol });
                        insertList.push(textNode);
                    }
                    if (body) {
                        const offset = node.startOffset + pointer + above.length;
                        const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = utils_1.sliceFragment(source, offset, offset + body.length);
                        const bodyNode = {
                            uuid: utils_1.uuid(),
                            type: ml_ast_1.MLASTNodeType.PreprocessorSpecificBlock,
                            nodeName: `#ps:${tag.type}`,
                            raw,
                            parentNode: node.parentNode,
                            prevNode: null,
                            nextNode: null,
                            isFragment: node.isFragment,
                            isGhost: false,
                            startOffset,
                            endOffset,
                            startLine,
                            endLine,
                            startCol,
                            endCol,
                        };
                        insertList.push(bodyNode);
                    }
                    text = below;
                    pointer = start + body.length;
                }
            }
            if (text) {
                const offset = node.endOffset - text.length;
                const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = utils_1.sliceFragment(source, offset, offset + text.length);
                const textNode = Object.assign(Object.assign({}, node), { uuid: utils_1.uuid(), type: ml_ast_1.MLASTNodeType.Text, raw,
                    startOffset,
                    endOffset,
                    startLine,
                    endLine,
                    startCol,
                    endCol });
                insertList.push(textNode);
            }
            utils_1.siblingsCorrection(insertList);
            if (parentNode) {
                parentNode.childNodes = insertList;
            }
            nodeList.splice(index, 1, ...insertList);
        }
        if (node.type === ml_ast_1.MLASTNodeType.StartTag) {
            for (const attr of node.attributes) {
                if (attr.type === 'ps-attr' || attr.value.raw === '' || !hasIgnoreBlock(attr.value.raw)) {
                    continue;
                }
                for (const tag of stack) {
                    if (attr.value.startOffset <= tag.index && tag.index < attr.value.endOffset) {
                        attr.value.raw = tag.startTag + tag.taggedCode + tag.endTag;
                        attr.isDynamicValue = true;
                    }
                }
            }
        }
    }
    return nodeList;
}
exports.restoreNode = restoreNode;
function snap(str, reg) {
    const matched = reg.exec(str);
    if (!matched) {
        return [-1, str];
    }
    const index = matched.index;
    const snapPoint = matched[0];
    const above = str.slice(0, index);
    const below = str.slice(index).slice(snapPoint.length);
    return [index, above, snapPoint, below];
}
function removeGlobalOption(reg) {
    return new RegExp(reg.source, reg.ignoreCase ? 'i' : '');
}
function prepend(reg, str) {
    return new RegExp(str + reg.source, reg.ignoreCase ? 'i' : '');
}
function append(reg, str) {
    return new RegExp(reg.source + str, reg.ignoreCase ? 'i' : '');
}
function hasIgnoreBlock(textContent) {
    return textContent.includes(const_1.MASK_CHAR);
}
