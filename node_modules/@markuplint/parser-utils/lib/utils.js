"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPotentialCustomElementName = exports.siblingsCorrection = exports.attributesToDebugMaps = exports.nodeListToDebugMaps = exports.walk = exports.getEndCol = exports.getEndLine = exports.getCol = exports.getLine = exports.sliceFragment = exports.tokenizer_v2 = exports.tokenizer = exports.uuid = void 0;
const ml_ast_1 = require("@markuplint/ml-ast");
const const_1 = require("./const");
const uuid_1 = require("uuid");
function uuid() {
    return uuid_1.v4();
}
exports.uuid = uuid;
/**
 *
 * @deprecated
 * @param raw
 * @param startLine
 * @param startCol
 * @param startOffset
 * @returns
 */
function tokenizer(raw, startLine, startCol, startOffset) {
    raw = raw || '';
    const endLine = getEndLine(raw, startLine);
    const endCol = getEndCol(raw, startCol);
    const endOffset = startOffset + raw.length;
    return {
        uuid: uuid(),
        raw,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startCol,
        endCol,
    };
}
exports.tokenizer = tokenizer;
function tokenizer_v2(raw, startOffset, rawCode) {
    raw = raw || '';
    const loc = sliceFragment(rawCode, startOffset, startOffset + raw.length);
    return Object.assign({ uuid: uuid() }, loc);
}
exports.tokenizer_v2 = tokenizer_v2;
function sliceFragment(rawHtml, start, end) {
    const raw = rawHtml.slice(start, end);
    return {
        startOffset: start,
        endOffset: end,
        startLine: getLine(rawHtml, start),
        endLine: getLine(rawHtml, end),
        startCol: getCol(rawHtml, start),
        endCol: getCol(rawHtml, end),
        raw,
    };
}
exports.sliceFragment = sliceFragment;
function getLine(html, startOffset) {
    return html.slice(0, startOffset).split(/\n/g).length;
}
exports.getLine = getLine;
function getCol(html, startOffset) {
    const lines = html.slice(0, startOffset).split(/\n/g);
    return lines[lines.length - 1].length + 1;
}
exports.getCol = getCol;
function getEndLine(html, line) {
    return html.split(/\r?\n/).length - 1 + line;
}
exports.getEndLine = getEndLine;
function getEndCol(html, col) {
    const lines = html.split(/\r?\n/);
    const lineCount = lines.length;
    const lastLine = lines.pop();
    return lineCount > 1 ? lastLine.length + 1 : col + html.length;
}
exports.getEndCol = getEndCol;
function walk(nodeList, walker, depth = 0) {
    for (const node of nodeList) {
        walker(node, depth);
        if ('childNodes' in node) {
            if (node.type === ml_ast_1.MLASTNodeType.EndTag) {
                continue;
            }
            if (node.childNodes && node.childNodes.length) {
                walk(node.childNodes, walker, depth + 1);
            }
            if ('pearNode' in node && node.pearNode) {
                walker(node.pearNode, depth);
            }
        }
    }
}
exports.walk = walk;
function nodeListToDebugMaps(nodeList, withAttr = false) {
    return nodeList
        .map(n => {
        const r = [];
        if (!n.isGhost) {
            r.push(tokenDebug(n));
            if (withAttr && 'attributes' in n) {
                r.push(...attributesToDebugMaps(n.attributes).flat());
            }
        }
        else {
            r.push(`[N/A]>[N/A](N/A)${n.nodeName}: ${visibleWhiteSpace(n.raw)}`);
        }
        return r;
    })
        .flat();
}
exports.nodeListToDebugMaps = nodeListToDebugMaps;
function attributesToDebugMaps(attributes) {
    return attributes.map(n => {
        const r = [
            tokenDebug(Object.assign(Object.assign({}, n), { name: n.type === 'html-attr' ? n.name.raw : n.raw })),
        ];
        if (n.type === 'html-attr') {
            r.push(`  ${tokenDebug(n.spacesBeforeName, 'bN')}`);
            r.push(`  ${tokenDebug(n.name, 'name')}`);
            r.push(`  ${tokenDebug(n.spacesBeforeEqual, 'bE')}`);
            r.push(`  ${tokenDebug(n.equal, 'equal')}`);
            r.push(`  ${tokenDebug(n.spacesAfterEqual, 'aE')}`);
            r.push(`  ${tokenDebug(n.startQuote, 'sQ')}`);
            r.push(`  ${tokenDebug(n.value, 'value')}`);
            r.push(`  ${tokenDebug(n.endQuote, 'eQ')}`);
            r.push(`  isDirective: ${!!n.isDirective}`);
            r.push(`  isDynamicValue: ${!!n.isDynamicValue}`);
            r.push(`  isInvalid: ${!!n.isInvalid}`);
        }
        if (n.potentialName != null) {
            r.push(`  potentialName: ${visibleWhiteSpace(n.potentialName)}`);
        }
        if (n.type === 'html-attr' && n.candidate) {
            r.push(`  candidate: ${visibleWhiteSpace(n.candidate)}`);
        }
        return r;
    });
}
exports.attributesToDebugMaps = attributesToDebugMaps;
function siblingsCorrection(nodeList) {
    for (let i = 0; i < nodeList.length; i++) {
        const prevNode = nodeList[i - 1] || null;
        const node = nodeList[i];
        const nextNode = nodeList[i + 1] || null;
        node.prevNode = prevNode;
        node.nextNode = nextNode;
    }
}
exports.siblingsCorrection = siblingsCorrection;
/**
 * valid name of custom element
 *
 * @see https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
 *
 * > - name must match the [PotentialCustomElementName](https://html.spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname) production
 * > - name must not be any of the following:
 * >   - annotation-xml
 * >   - color-profile
 * >   - font-face
 * >   - font-face-src
 * >   - font-face-uri
 * >   - font-face-format
 * >   - font-face-name
 * >   - missing-glyph
 *
 * ASCII-case-insensitively.
 * Originally, it is not possible to define a name including ASCII upper alphas in the custom element, but it is not treated as illegal by the HTML parser.
 *
 * @param tagName
 */
function isPotentialCustomElementName(tagName) {
    switch (tagName) {
        case 'annotation-xml':
        case 'color-profile':
        case 'font-face':
        case 'font-face-src':
        case 'font-face-uri':
        case 'font-face-format':
        case 'font-face-name':
        case 'missing-glyph': {
            return false;
        }
    }
    return const_1.rePCEN.test(tagName);
}
exports.isPotentialCustomElementName = isPotentialCustomElementName;
function tokenDebug(n, type = '') {
    return `[${n.startLine}:${n.startCol}]>[${n.endLine}:${n.endCol}](${n.startOffset},${n.endOffset})${n.nodeName || n.potentialName || n.name || n.type || type}: ${visibleWhiteSpace(n.raw)}`;
}
function visibleWhiteSpace(chars) {
    return chars.replace(/\n/g, '⏎').replace(/\t/g, '→').replace(/\s/g, '␣');
}
